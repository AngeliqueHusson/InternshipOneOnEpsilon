{"kind": "youtube#videoListResponse", "etag": "\"tnVOtk4NeGU6nDncDTE5m9SmuHc/NO7k58CaFPpAD3ulBAEjfN4t0Bo\"", "pageInfo": {"totalResults": 1, "resultsPerPage": 1}, "items": [{"kind": "youtube#video", "etag": "\"tnVOtk4NeGU6nDncDTE5m9SmuHc/rTIuQ-luj31eR6GTz81yrAz4g5M\"", "id": "iPLQgXUiU14", "snippet": {"publishedAt": "2011-12-13T22:57:43.000Z", "channelId": "UCMpizQXRt817D0qpBQZ2TlA", "title": "Can you crack the combination lock? - Solution", "description": "The sequence 11221 contains all 2-digit combinations using the numbers 1 and 2.\r\n\r\nA sequence such as that is called a De Bruijn sequence. I show you three methods to find such sequence. The first two involve making diagrams called graphs, and either taking a path that visits every node of a graph (a hamilton path), or a path that visits every edge of a graph (euler path). The third method is an algorithm for making 'Lyndon words' which if you string them together will make our De Bruijn sequence.\r\n\r\nDe Bruijn Sequences: http://en.wikipedia.org/wiki/De_Bruijn_sequence\r\n\r\nHamilton Path: http://en.wikipedia.org/wiki/Hamiltonian_path\r\n\r\nEuler Path: http://en.wikipedia.org/wiki/Eulerian_path\r\n\r\nLyndon Words: http://en.wikipedia.org/wiki/Lyndon_word\r\n\r\n\r\nThere is an efficient method of generating a list of all Lyndon words of lengths that divide n, using the digits 1 to k, which involves a lot less crossing off. This is the method I used to make the final sequence in the video. I did not describe the method in the video, so let me describe it here:\r\n\r\nStart the list with a sequence of n 1s, i.e. 11 . . . 1. We will generate successive words until we reach kk . . . k. For any word A = a1a2 . . . an, the successor of A is obtained as follows:\r\n\r\n1. Let i be the largest value such that ai is less than k\r\n2. Let B = a1a2 . . . ai-1(ai + 1)\r\n3. Then the successor of A is the first n characters of BB . . . B.\r\n\r\nWe then decided to reject, replace, or keep the successor of A depending on the value of i:\r\n\r\n1. If i does not divide n, the successor of A appears earlier on the list under rotation. Generate a successor to the word before removing it from the list.\r\n2. If i divides n but not equal to n, the successor of A is periodic. Generate a successor to the word then replace BB . . . B with B. Replace 11 . . . 1 at the start of the list with 1.\r\n3. If i = n we keep the successor of A.\r\n\r\nThis creates a list of Lyndon words, of lengths that divide n, written in lexicographic order. \r\n\r\nTogether, this list creates a De Bruijn sequence of length k^n, containing all the combinations of length n (if the sequence wraps around) using the digits 1 to k.\r\n\r\n\r\nOk then, here's an extra one for you to try. Use the algorithm to give me a sequence containing all 6-digit combinations using the numbers 1 and 2. So combinations like 111111, 112121, 211122 etc. The sequence is 64-digits long (if you let the sequence wrap back to the start).", "thumbnails": {"default": {"url": "https://i.ytimg.com/vi/iPLQgXUiU14/default.jpg", "width": 120, "height": 90}, "medium": {"url": "https://i.ytimg.com/vi/iPLQgXUiU14/mqdefault.jpg", "width": 320, "height": 180}, "high": {"url": "https://i.ytimg.com/vi/iPLQgXUiU14/hqdefault.jpg", "width": 480, "height": 360}, "standard": {"url": "https://i.ytimg.com/vi/iPLQgXUiU14/sddefault.jpg", "width": 640, "height": 480}, "maxres": {"url": "https://i.ytimg.com/vi/iPLQgXUiU14/maxresdefault.jpg", "width": 1280, "height": 720}}, "channelTitle": "singingbanana", "tags": ["maths", "math", "mathematics", "problem", "puzzle", "combination", "lock", "code", "break", "crack", "sequence", "combinatorics", "de", "brujin", "lyndon", "words", "graph", "theory", "euler", "eulerian", "hamilton", "hamiltonian", "path", "cycle", "circuit", "computing", "robotics", "dna", "sequencing"], "categoryId": "27", "liveBroadcastContent": "none", "defaultLanguage": "en-GB", "localized": {"title": "Can you crack the combination lock? - Solution", "description": "The sequence 11221 contains all 2-digit combinations using the numbers 1 and 2.\r\n\r\nA sequence such as that is called a De Bruijn sequence. I show you three methods to find such sequence. The first two involve making diagrams called graphs, and either taking a path that visits every node of a graph (a hamilton path), or a path that visits every edge of a graph (euler path). The third method is an algorithm for making 'Lyndon words' which if you string them together will make our De Bruijn sequence.\r\n\r\nDe Bruijn Sequences: http://en.wikipedia.org/wiki/De_Bruijn_sequence\r\n\r\nHamilton Path: http://en.wikipedia.org/wiki/Hamiltonian_path\r\n\r\nEuler Path: http://en.wikipedia.org/wiki/Eulerian_path\r\n\r\nLyndon Words: http://en.wikipedia.org/wiki/Lyndon_word\r\n\r\n\r\nThere is an efficient method of generating a list of all Lyndon words of lengths that divide n, using the digits 1 to k, which involves a lot less crossing off. This is the method I used to make the final sequence in the video. I did not describe the method in the video, so let me describe it here:\r\n\r\nStart the list with a sequence of n 1s, i.e. 11 . . . 1. We will generate successive words until we reach kk . . . k. For any word A = a1a2 . . . an, the successor of A is obtained as follows:\r\n\r\n1. Let i be the largest value such that ai is less than k\r\n2. Let B = a1a2 . . . ai-1(ai + 1)\r\n3. Then the successor of A is the first n characters of BB . . . B.\r\n\r\nWe then decided to reject, replace, or keep the successor of A depending on the value of i:\r\n\r\n1. If i does not divide n, the successor of A appears earlier on the list under rotation. Generate a successor to the word before removing it from the list.\r\n2. If i divides n but not equal to n, the successor of A is periodic. Generate a successor to the word then replace BB . . . B with B. Replace 11 . . . 1 at the start of the list with 1.\r\n3. If i = n we keep the successor of A.\r\n\r\nThis creates a list of Lyndon words, of lengths that divide n, written in lexicographic order. \r\n\r\nTogether, this list creates a De Bruijn sequence of length k^n, containing all the combinations of length n (if the sequence wraps around) using the digits 1 to k.\r\n\r\n\r\nOk then, here's an extra one for you to try. Use the algorithm to give me a sequence containing all 6-digit combinations using the numbers 1 and 2. So combinations like 111111, 112121, 211122 etc. The sequence is 64-digits long (if you let the sequence wrap back to the start)."}, "defaultAudioLanguage": "en-GB"}}]}
